#perl -MFile::Slurp -MXML::Simple -MData::Dumper -e'print scalar Dumper ( XMLin( read_file(shift @ARGV).""))' 
# Usage
# --edit expects the output of svn log --xml as the first argument, and an intermediate
#        file where we will be storing munged up xml that trags your tags and edits
# --generate expects the intermediate file as the first argument and a plaintext
#            changelog file as the second argument.  This changelog file is clobbered
#
# svn log --limit=100 --xml >> changelog.xml
# generate-changelog --edit changelog.xml changelog.interim.xml
# generate-changelog --generate changelog.interim.xml Changelog
#
# if you wish to do iterative editing, you can do
# cp changelog.xml changelog.xml.orig
# mv changelog.interim.xml changelog.xml
# generate-changelog --edit changelog.xml changelog.interim.xml

use warnings;
use strict;
use Term::ANSIScreen;
use Text::Autoformat;
use YAML;
use File::Slurp;
use XML::Simple;
use Term::ReadKey;
use Data::Dumper;
         use File::Temp qw/ tempfile tempdir /;
my @tags = qw(doc install core plugin security view f-bug t-discard backward-compatiblity-problem u-pubsub r-crud e-testing);

my %tags = map { substr($_,0,1) => $_ } @tags;
my $mode = shift @ARGV;
my ($source,$dest);
if ($mode eq '--generate') {
     $source = shift @ARGV;
     $dest = shift @ARGV;

}
elsif ($mode eq '--edit') {
     $source = shift @ARGV;
     $dest = shift @ARGV;

}

unless ($source && -f $source && $dest) { die "$0 --generate SOURCEFILE DESTFILE\n or \n$0 --edit SOURCEFILE DESTFILE" }


my $data = XMLin(read_file($source)."");


if ($mode eq '--edit') {

foreach my $entry (@{$data->{'logentry'}}) {
   my %entries; 
    foreach my $entry (@{$data->{'logentry'}}) {
        push @{$entries{$entry->{section}||'uncategorized'}}, $entry;
    }
    foreach my $key ( keys %entries) {
        foreach my $entry (@{$entries{$key}}){ 
    act_on($entry);
    }
    }
}

    do_quit();
} elsif ($mode eq '--generate') {
   my %entries; 
    foreach my $entry (@{$data->{'logentry'}}) {
        push @{$entries{$entry->{section}||'uncategorized'}}, $entry;
    }

    open (my $fh, ">$dest") or die "Can't open $dest for writing";

    foreach my $key ( keys %entries) {
    my $title = $key;
    $title =~ s/^\w\-//;
        print $fh uc($key)."\n";
        print $fh "=" x length($key) ;
        print $fh "\n\n";

        foreach my $entry (@{$entries{$key}}){ 

        print $fh format_entry($entry) ;
        print $fh "\n";
        }
    }

    close $fh;

}

sub act_on {
    my $entry = shift;

    my $console = Term::ANSIScreen->new;
    while (1) {
    my $command = '';
    while (!$command) {
        $console->Cls;
            $console->Cursor(1,1);


        if (!$entry->{'edited_msg'} && ref($entry->{msg})) { $entry->{'edited_msg'} = Dumper($entry->{'msg'}); }
        print format_entry ($entry => 1);
    
    
        my $in = getchar();


        if ($in eq 's') {
            return;
        } 
        elsif ($in eq 'c') { $command = 'chomp'; }
        elsif ($in eq 'e') { $command = 'edit'; }
        elsif ($in eq 'q') { $command = 'quit'; }
        elsif ($in eq 't') { $command = 'tag' }
        elsif ($in eq ' ') {
            return
        }
    }
    if ($command eq 'tag') {
        tag($entry);
    }
    elsif ( $command eq 'write' ) {
        warn "Writing";
    } elsif ( $command eq 'chomp' ) {
        my $msg = ( $entry->{'edited_msg'} || $entry->{'msg'} );
        my @lines = split( "\n", $msg );
        shift @lines;
        $entry->{'edited_msg'} = join( "\n", @lines );
    } elsif ( $command eq 'edit' ) {
        warn "Chomping";
        my ( $fh, $filename ) = tempfile();
        print $fh ( $entry->{'edited_msg'} || $entry->{'msg'} ) || die $!;
        close $fh;
        system( ( $ENV{EDITOR} || 'vi' ), $filename );
        $entry->{'edited_msg'} = read_file($filename);
    } elsif ($command eq 'quit') {

        do_quit();
    }

    }

}

sub tag {
    my $entry = shift;
    my $tag;
    print "Valid tags are: " . join( ', ', @tags ) . "\n";
    while ( !$tag ) {
        my $key = getchar();
        return if ( $key eq  ' ' );
        print "You picked " . $key . "\n";
        if ( $tags{$key} ) {
            $tag = $tags{$key};
            print "You tagged it $tag\n";
        } else {
            print "NO. THAT IS NOT A VALID TAG\n";

        }
    }
    $entry->{section} = $tag;

}

sub do_quit {
my $out;
    open( $out, ">$dest" );

    print $out XMLout($data,  NoAttr => 1 );
    close($out);
    exit;

}

sub getchar {

    ReadMode 4;
        my $key = ReadKey(0);
            ReadMode 0;

    return $key
            }


sub format_entry {
    my $entry = shift;
    my $verbose = shift ||0; 
    my $text = '';
    if  ($verbose ) {
        $text .= "r".$entry->{revision}." - ";
        $text .= $entry->{'section'} || "UNCATEGORIZED - HIT 't'";   
        $text .= "\n".("="x60)."\n";
    }

    my $msg = ( $entry->{'edited_msg'} || $entry->{'msg'});

    if ($msg =~ /^[\s\*]*\w/) {
        $msg =~ s/^[\s\*]*/ * /;
    }

    $msg =~  s/\n+$//g;
    $msg .= " - ".$entry->{'author'}."\n";


     $msg =   autoformat ($msg,  { left=>0, right=>78 });
     $msg =~  s/\n+$//g;
     $text .= $msg."\n";
     if  ($verbose ) {
         $text .= YAML::Dump( $entry->{'paths'});
         $text .= "\n";
     }
     return $text;
}
